---
layout: share-distill
title: '[연구 8] 원료 임베딩 클러스터링'
date: 2023-11-05
giscus_comments : true
description: "원료들을 벡터로 표현하고 임베딩하여 유사 원료를 확인하는 방법에 대한 논의"
authors: 
    - name: Bumjin Park
      affiliations:
        name: KAIST

img: https://drive.google.com/uc?export=view&id=1-QILaND0et_KpWix8CZi5ICZCX--Yhl1
---


## 벡터화 

<img src="https://drive.google.com/uc?export=view&id=1tuteKKf0ZehMow4g25kVpP3bxNYJYKqL" style='width:100%;border:1px solid #FFDDDD;'>
<img src="https://drive.google.com/uc?export=view&id=1DSeEosfGztjV8A4c_TEbdEkPloFYWTC_" style='width:100%;border:1px solid #FFDDDD;'>



## Method1: 코드에 대한 정보 바탕 


원료에 대한 배합목적 
<d-code language="python">

23309 : [1, 9, 2, 36, 7, 3]
23310 : [7]
23311 : [2, 7, 1]
23312 : [2, 7]
23313 : [7, 11]
23314 : [1, 36, 2, 73]
23316 : [36]
23317 : [8, 36]
23318 : [36]
23319 : [2, 36]
23320 : [36, 7, 3]
23321 : [7]

</d-code>

(9973, 91)

<img src="https://drive.google.com/uc?export=view&id=1TWPL6KJ4oF6AxXH5IDisg1PIp09desyP" style='width:100%;border:1px solid #FFDDDD;'>

<img src="https://drive.google.com/uc?export=view&id=1DIYjrYxQXd9F46j4tawrHCOLJV_3sfqB" style='width:100%;border:1px solid #FFDDDD;'>

<img src="https://drive.google.com/uc?export=view&id=18w-NsuCnbbeg3CBQ5No79Oof380oPaX0" style='width:100%;border:1px solid #FFDDDD;'>




## Method2:  Differential Feature Learning 


The code mapping problem has two components $h_{\theta_{map}}$ and  $g_{\theta_{reg}}$ to compute predict any type of outputs with the amount of materials for the input. The direct regression function $f_\theta$  is the composition of two functions. 

$$ 
f_\theta = g_{\theta_{reg}} \circ h_{\theta_{map}}
$$

The input and output spaces for each module are as follows: 

* $h : \mathbb{R}^{N_{code}} \rightarrow \mathbb{R}^{N_{entry}}$
* $g : \mathbb{R}^{N_{entry}} \rightarrow \mathbb{R}$
* $f : \mathbb{R}^{N_{code}} \rightarrow \mathbb{R}$


End-to-End code entry preference learning is optimized by 

$$ 
\theta_{reg}^{\star},\theta_{map}^{\star}  = \arg \min_{\theta_{map}, \theta_{reg}} \mathcal{L}( f_\theta (x), y)
$$

One way to model $h_{\theta_{map}}$ is to map individual code $c$ to a representation vector $\mathbf{h}_c \in \mathbb{R}^{N_{entry}}$ and combine the $\mathbf{h}_c$ with amounts. 

$$
h_{\theta_{map}} (A_1, \cdots, A_{N_{code}}) = \sum_{c} A_c \cdot \mathbf{h}_c
$$

To minimize the loss, both weights $\theta_{reg}$ and $\theta_{map}$ are jointly optimized. 


### 벡터 개수에 따른 성능 



<center markdown="1">

### number code  == 2
<img src="https://drive.google.com/uc?export=view&id=1Q57jVEg7jJuIEk3LaRkAO-hbrrIiZejL" style='width:100%;border:1px solid #FFDDDD;'>
<img src="https://drive.google.com/uc?export=view&id=1VoG04J6MLpL-3PWk--eTSd7Q40_aCPBe" style='width:100%;border:1px solid #FFDDDD;'>

### number code  == 5
<img src="https://drive.google.com/uc?export=view&id=1yvoC4uM5-B5S9HV6CbljZU89Ai_mhCJL" style='width:100%;border:1px solid #FFDDDD;'>
<img src="https://drive.google.com/uc?export=view&id=1NGiJ7mChfj7QRoFGrKJHjAjqKkxrouke" style='width:100%;border:1px solid #FFDDDD;'>

### number code  == 10
<img src="https://drive.google.com/uc?export=view&id=1zVwOfKrhXAwtsjkZJucOfenQSymy12AQ" style='width:100%;border:1px solid #FFDDDD;'>
<img src="https://drive.google.com/uc?export=view&id=1gPr-VE3BSLfRKveH5Pgbl-AVvMLsvBzS" style='width:100%;border:1px solid #FFDDDD;'>

### number code  == 25
<img src="https://drive.google.com/uc?export=view&id=1uFQzCfACZ1iO86bIhFUBBNmFb1CgRC72" style='width:100%;border:1px solid #FFDDDD;'>
<img src="https://drive.google.com/uc?export=view&id=1uBftX4UDIc0pGPCJTPq79H5vAGukCJuq" style='width:100%;border:1px solid #FFDDDD;'>
</center>


### 클러스터링 
