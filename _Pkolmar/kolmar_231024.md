---
layout: share-distill
title: '[연구 5] 1+2차처방 데이터 / XG boosting'
date: 2023-10-17
giscus_comments : true
description: "1,2차 데이터 동시 취합 및 XGBoost 적용"
authors: 
    - name: Bumjin Park
      affiliations:
        name: KAIST

img: https://drive.google.com/uc?export=view&id=1oeT2ai2o5n8EeEFi-Dbsk7uqN4CZhmt6
---

## 1. Report Info   

<div class="spanbox" markdown="1" style="width:40rem;background-color:#FFFDFD;">
1. 👨🏻‍💻 **Code Release**:  Tag [v23.10.23.1](https://github.com/fxnnxc/kolmar/tree/v23.10.23.1)
2. 📂 **Raw Data** :  (3.1, `raw_data:receipt_3`)  # 3.1 은 1차 및 2처 처방을 합치고 코드별로 합산한 데이터
3. 🗂️ **Datasets** :  (2, `ds:receipt_3_ml`)  
4. 👾 **Models** :  1~8 까지 8개의 ML 모델 
5. 🦄 **Trainers** : (1, `sklearn_regressor`)
6. 📌 **Related Notebooks** 
  * [receipt_3 target dist.ipynb](https://github.com/fxnnxc/kolmar/blob/v23.10.23.2/labs/receipt_3_eda/dataset.ipynb)
  * [plot_rmse.ipynb](https://github.com/fxnnxc/kolmar/blob/v23.10.23.2/labs/receipt_3_rmse/plot_rmse.ipynb)
  * [pdp.ipynb](https://github.com/fxnnxc/kolmar/blob/v23.10.23.2/labs/receipt_3_rmse/pdp.ipynb)
</div>



## 3차 처방 데이터 


1차 처방데이터와 2차 처방데이터를 취합한 데이터셋 구축하였다. 데이터셋에 따른 모델 학습은 향후 다시 구분하여 학습을 진행할 수 있기에 특별한 이유가 없을 때까지는 증가된 데이터셋으로 학습 및 분석을 진행한다. 3차 처방데이터는 1,2차 데이터를 합친 것으로 다음과 같으 처리를 통하여 총 `1745개`의 입력데이터가 존재하며, 코드 개수는 `5485개`이다. 

<d-code language='python'>
[INFO] dropping NaN targets...
[INFO] sum by duplicated lab numbers for targets...
[INFO] modified number of targets by dropping NaN and duplication: 1771 --> 1745
[INFO] fill one-hot code for all targets in the order of unique_formulas in data_raw excluding codes if code-idx < 5485
100%|██████████| 1745/1745 [00:18<00:00, 92.10it/s]
--------------------------------------------------
[INFO] 🗂️ Dataset: Receipt3DatasetBaseML X:(1745, 5485)  Y:(1745,)
</d-code>


* 학습데이터 (1221, 5485), (1221,), 
* 테스트데이터 (524, 5485), (524,)

<center>
<div class="spanbox" markdown="1" style="width:40rem;background-color:#FFFDFD;margin-left:0rem;">
### 1차/2차 점도 예측 목표 
<img src="https://drive.google.com/uc?export=view&id=1759r2Afe8HKChHH_oNoePBw9akxC8RNq" style='width:39%'>
<img src="https://drive.google.com/uc?export=view&id=16-ZXy2tI6s72_agj7pzy4PTM7IrcB4hd" style='width:39%'>
### 3차 처방 데이터의 점도값 분포는 다음과 같다.
<img src="https://drive.google.com/uc?export=view&id=1WCDCzgN8LAad5xYpP7g4D0ZMd4k01QbF" style='width:80%'>
</div>
</center>

## 물질의 양과 점도의 상관관계

각 코드에 대해서 단순선형모델 및 상관관계를 구해보면 다음과 같다.

<img src="https://drive.google.com/uc?export=view&id=1h50lUJTqPyeaMWt2v8OiX2uJpU7C3IRU" style='width:80%'>

* 전체 데이터는 [correlation.xlsx](https://docs.google.com/spreadsheets/d/1PbeJslr2Rv1o-5FHJ0SMB091RzlnfUle/edit?usp=sharing&ouid=112523016502479227051&rtpof=true&sd=true) (보안접근)에서 확인할 수 있다. 

## 8개의 머신러닝 모델 학습 및 결과 

<img src="https://drive.google.com/uc?export=view&id=1LhC7shBOObQGoLo2ftxgK8Q-Wjajq-vi" style='width:200%;margin-left:-10rem;'>


## PDP 

PDP 는 기존 학습데이터에서 코드를 정하고 0~100까지 강제로 변화시킨 데이터를 모델에 넣어 평균적인 코드의 예측값을 보는 방법이다. 

* x-축: 특정 코드에 대한 값  
* y-축: 평균 점도 (3차 처방 데이터)

<div class="spanbox" markdown="1" style="width:60rem;background-color:#FFFDFD;margin-left:-5rem;">
### PDP
<center>
<img src="https://drive.google.com/uc?export=view&id=1v-rD7f-pfwN8meUaM2lwZXt_Z740vLR7" style='width:100%'>
<img src="https://drive.google.com/uc?export=view&id=1aDLc5Cdh6XX5m5OzFFaGgzenG1onFKWj" style='width:100%'>
</center>
</div>




## 데이터셋의 본질적인 문제 

프로젝트를 진행하면서 점도 예측에 대해서 어려운 점은 코드 개수가 5000개가 넘는데, 데이터의 샘플은 1700여개라는 점이다. 이는 학습데이터가 아주 적은 것을 의미하며, 학습 모델에 몇 가지 문제점을 지니고 있다. 

1. 많이 사용된 코드에 적합하게 학습된다. 적은 코드는 영향을 거의 미치지 못한다. (대부분 값이 0으로 들어가기 떄문에)
2. 적은 샘플을 가지는 코드가 큰 weight을 지닐 수 있다. 이 경우, 일반화가 되었다고 판단 오류를 내릴 가능성이 높다. 

따라서 적은 샘플을 가지는 코드는 학습이 제대로 진행되지 못했을 가능성이 높다. 그렇다면, 현재 상황에서 필요한 것은 단순히 코드로부터 점도를 예측하는 것을 넘어서, 
적은 샘플을 지니는 코드로부터 학습하는 방법이다. 머신러닝/딥러닝 학습 전에 먼저 목표로 하는 점은 다음과 같다. 

1. 충분한 실험 개수를 지니느 코드에 대한 점도 영향력 측정 
2. 적은 실험 개수를 지니는 코드에 대해서 예측 방법 제안. 




## 점도 모델링 

물과 꿀을 섞는 것을 예로 들어보면, 물과 꿀은 서로 점도를 지니고 있다. 두 물질은 서로 다른 점도 $\rho_1$ $\rho_2$ 를 지니고 있으며, 화학적인 성질 $\psi_1, \psi_2$ 를 가지고 있다. 
두 개를 $x$ 와 $1-x$ 만큼 섞는 경우 물보다는 진하고 꿀보다는 연한 상태가 되기에,  점도 $\rho$ 는  $\[ \rho_1, \rho_2 \]$ 에 놓이게 됨이 자명한데, 만일 화학적인 성질로부터 점도가 유도될 수 있다면, 혼합물의 점도 $\rho$ 는 적당한 함수 $f$에 의해서 결정난다. 

$$
\begin{equation}
\rho = f(\psi_1, \psi_2, x, 1-x)
\end{equation}
$$

딥러닝의 목적은 근사함수 $f_\theta$ 를 찾는 것으로, 적당한 모델 파라미터 $\theta$ 로부터 Loss를 최소화는 파라미터를 찾는다. 

$$
\begin{equation}
\theta^\star = \arg \min_\theta \mathcal{L}(f_\theta(x, x-1), f(\psi_1, \psi_2, x, 1-x))
\end{equation}
$$

레올로지로부터 얻어지는 값 $y$는 $f(\psi_1, \psi_2, x, 1-x)$ 를 대체하므로, 실험적으로 얻어진 값 $y$ 로 $f$ 를 대체하여 $\theta$를 찾는다. 

$$
\begin{equation}
\theta^\star = \arg \min_\theta \mathcal{L}(f_\theta(x, x-1), y)
\end{equation}
$$

적은 개수의 코드에 대해서 수식 1과 같이 화학적인 성질 및 섞는 비율에 의해서 점도가 결정난다면, 비슷한 화학적 성질 및 양을 지니는 물질에 대해서는 $\rho$ 값이 유사하게 나타날 것이다. 
이는 $f$ 함수가 화학적성질 및 섞는 비율에 대해서 Smooth 한 성질이 있다고 가정하는 경우에 가능하다. 어찌되었던 성질이 비슷한 두 물질은 서로 교체되어도 $\rho$ 값이 크게 변하지 않는다는 점이다. 
따라서, 5485개의 코드에 대해서 점도를 결정하는 유사한 성질을 유도해낼 수 있다면, 비록 샘플 수가 적을지라도 유사한 코드 중 가장 많은 샘플로 대체되면 문제가 해결된다. 

(만일 화학적인 특성 없이 단순하게 비율대로 결정이 난다면, $\rho = \rho_1 x_1 + \rho_2 x_2$ 식으로 쓸 수 있을 것이다. 이 경우, 각 코드별로 점도를 예측하고, 단순하게 곱해서 더하면 점도가 예측되어야 한다. 각 물질별로 단 한번의 실험으로 점도를 결정할 필요가 있으므로 코드 개수만큼 실험을 돌려야 한다. 결국 코드 수만큼 필요하다면, 샘플이 코드 개수보다 적은 경우는 Least Square에서 Rank가 더 작은 상태와 동일하다. )

### 3개 이상을 섞는 경우 

코드 개수 $K$ 를 섞는 경우, 각 물질의 특성을 $\psi_k$, 양을 $x_k$ 라고 하면, 해당 조합을 섞었을 때 결정되는 점도는 다음과 같은 식으로 유도된다. 

$$
\begin{equation}
\rho = f(\psi_1, \psi_2, \cdots, \psi_K, x_1, x_2, \cdots, x_{K-1}  )
\end{equation}
$$

샘플이 적은 코드 $j$ 에 대해서 화학적인 특성이 유사하다면, 코드 $j$ 는 

$$
\begin{equation}
\hat{k} = \arg \min_{k\in [K_j]} d(\psi_k, \psi_j)
\end{equation}
$$

코드 인덱스 $k$ 가 데이터 수로 정렬되어 있다고 가정할 때, $K_j$ 는 코드 $j$ 보다 샘플수가 충분히 많은 코드의 인덱스이다. 
이로 인해서, $j$ 코드의 특성 $\psi_j$ 는 $\psi_{k'}$으로 치환된다. 궁극적으로 점도 $\rho$ 를 결정하는 파라미터가 하나 줄어들게 되는 것이다. 
이러한 코드 치환은 $d(\psi_k, \psi_j)$ 에서 발생하는 에러가 작을수록 바람직하며, 적절히 요구되는 특성이 유사한 코드가 있다면, $d(\cdot, \cdot)$ 은 작아진다. 

이 분석을 통해서 최종적으로 모델링 해야 하는 것은 점도 예측에 유의미한 $\psi$ 표현을 찾는 것이고, 찾아낸 표현으로부터 코드 치환 알고리즘을 최적화하는 경우, 
수식1의 점도 결정 함수가 옳다는 가정하에서 치환을 통한 방식은 적은 에러를 지니게 된다. 

--- 

### Direct Solution of 5 using distribution

물질의 성질 $\psi$ 값은 점도를 결정지어야 하기 때문에 적절한 $\psi$ 를 모델링 하는 것은 쉽지 않다. 
대신 Equation 5 에서 구하는 distance를 확률적인 차이로 치환할 수 있다. 두 개의 코드에 대해서 점도의 확률분포가 얼마나 유사한지, 다른지를 판단한다면, 화학적인 성질 $\psi$를 구하지 않고, 
$k$ 를 구할 수 있다.

$$
\arg \min_{k \in [K_j]} d(\psi_j, \psi_k) = \arg \min_{k \in [K_j]} d(p(Y|X_j;\hat{X}), p(Y|X_k;\hat{X})) 
$$

즉, 점도의 예측값이 유사하다면, 코드는 다른 코드로 치환될 수 있는 것이다. 이 때 다른 코드들은 최대한 비슷한 상황에서 진행되어야 한다. 

(사실 이 부분을 정확하게 수식으로 모델링 하려면 고생이 좀 필요할 것 같다.)